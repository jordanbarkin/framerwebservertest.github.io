// Generated by CoffeeScript 1.12.7
(function() {
  var CircularProgress,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  CircularProgress = (function(superClass) {
    extend(CircularProgress, superClass);

    function CircularProgress(options) {
      CircularProgress.__super__.constructor.call(this, options);
      this.strokeWidth = 3;
      this.circleSize = 100;
      this.backgroundColor = null;
      this.createElement();
    }

    CircularProgress.prototype.createElement = function() {
      var footer, header;
      this.innerCircle = new Layer({
        x: 0,
        y: 0,
        width: this.circleSize,
        height: this.circleSize,
        superLayer: this,
        backgroundColor: null
      });
      this.outerCircle = new Layer({
        x: 0,
        y: 0,
        width: this.circleSize,
        height: this.circleSize,
        superLayer: this,
        backgroundColor: null
      });
      this.innerCircle.center();
      this.outerCircle.center();
      header = '<svg width="100px" height="100px" x="0px" y="0px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" xmlns:xlink="http://www.w3.org/1999/xlink"> <defs></defs>';
      footer = '</svg>';
      this.innerCircle.html = header + '<circle id="c" cx="50" cy="50" r="48" stroke="#3F3F3F" stroke-width="' + this.strokeWidth + '" fill="none"></circle>' + footer;
      return this.outerCircle.html = header + '<circle id="progress-outer-circle" transform="rotate(270,50,50)" cx="50" cy="50" r="48" stroke="#fff" stroke-width="' + this.strokeWidth + '" fill="none"></circle>' + footer;
    };

    CircularProgress.define("value", {
      set: function(v) {
        var c, pct, r, svgPath;
        svgPath = document.getElementById('progress-outer-circle');
        r = this.width / 2;
        c = Math.PI * (r * 2);
        pct = (1 - v) * c;
        svgPath.style.strokeDasharray = c;
        return svgPath.style.strokeDashoffset = pct;
      }
    });

    return CircularProgress;

  })(Layer);

  module.exports = (function(superClass) {
    extend(exports, superClass);

    function exports(options) {
      exports.__super__.constructor.call(this, options);
      if (options == null) {
        options = {};
      }
      this.width = Screen.width;
      this.height = Screen.height;
      this.backgroundColor = "black";
      this.imagesLoaded = 0;
      this.onload = options.onload;
      this.images = [];
      this.progress = new CircularProgress({
        width: 100,
        height: 100,
        superLayer: this
      });
      this.progress.center();
      this.progress.value = 0;
    }

    exports.prototype.addImage = function(src) {
      return this.images.push(src);
    };

    exports.prototype.addFramerImages = function() {
      var i, layer, len, ref, results;
      ref = Framer.CurrentContext._layers;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        layer = ref[i];
        if (layer.image) {
          results.push(this.images.push(layer.image));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    exports.prototype.load = function() {
      var i, image, len, ref, results, src;
      this.addFramerImages();
      ref = this.images;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        src = ref[i];
        image = new Image();
        image.onload = (function(_this) {
          return function() {
            return _this.imageDidLoad();
          };
        })(this);
        image.onerror = (function(_this) {
          return function() {
            return _this.imageDidLoad();
          };
        })(this);
        results.push(image.src = src);
      }
      return results;
    };

    exports.prototype.imageDidLoad = function() {
      this.imagesLoaded++;
      this.progress.value = this.imagesLoaded / this.images.length;
      if (this.imagesLoaded >= this.images.length) {
        return this.finishedLoad();
      }
    };

    exports.prototype.finishedLoad = function() {
      if (this.onload) {
        this.onload();
      }
      return this.destroy();
    };

    return exports;

  })(Layer);

}).call(this);
